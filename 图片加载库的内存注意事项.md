# 图片加载库的内存注意事项 

图片加载在客户端开发中是必不可少的功能，市面上也有很多非常优秀的图片加载库，比如ImageLoader、Picasso、Glide、Fresco等广受欢迎的开源图片加载库，这些开源库能够满足大部分的应用场景。但是在应用的具体开发过程中，出现一些开源库不能满足业务需求的情况，这个时候就需要我们自己开发一套图片加载库，本文就图片加载库开发过程中碰到的一些内存优化点进行讨论。
## 设置图片的色彩选项
在Android中，用一个包含4个字节的32位整数来表示一个像素的颜色和透明度，这4个字节从高到低分别表示Alpha，R，G，B四个通道。每个通道使用1个字节8位表示，因此，每个通道的值范围是[0， 0xFF)，其中，0x00表示颜色最浅（Alpha通道表示完全透明），0xFF表示颜色最深（Alpha通道表示完全不透明），例如0xFFFFFFFF表示该像素完全透明的红色。
在Android中，可以通过设置Bitmap中的Options.inPreferredConfig值来降低内存消耗，其中：
ARGB_8888（默认值）：每个像	素4字节，共32位。 
Alpha_8：只保存透明度，共8位，1字节。 
ARGB_4444： 就是由4个4位组成，共16位，2字节。
RGB_565:R为5位，G为6位，B为5位共16位，2字节。
这些都是图片色彩的存储方法，每个位图的位数越高代表其可以存储的颜色信息越多，当然图像也就越逼真。如果不需要透明度信息，就将其设置为RGB_565，可以减少一半的内存。
## 及时回收内存
在Android中，可以通过设置Bitmap中的Options.inPurgeable和Options.inInputShareable，可以让系统能及时回收内存。 
将Options.inPurgeable设置为true，则使用BitmapFactory创建的Bitmap用于存储Pixel的内存空间，在系统内存不足时可以被回收，当应用需要再次访问该Bitmap的Pixel时，系统会再次调用BitmapFactory 的decode方法重新生成Bitmap的Pixel数组。设置为false时，表示不能被回收。这样BitmapFactory在不停decodeByteArray创建新的Bitmap对象，不同设备的内存不同，因此能够同时创建的Bitmap个数可能有所不同，200个bitmap足以使大部分的设备重新OutOfMemory错误。 当Options.inPurgeable设为true时，系统中内存不足时，可以回收部分Bitmap占据的内存空间，这时一般不会出现OutOfMemory 错误。
Options.inInputShareable是设置是否深拷贝，与Options.inPurgeable结合使用，Options.inPurgeable为false时，那么该设置将被忽略。将Options.inPurgeable和Options.inInputShareable同时设置为true，那么它可以决定位图是否能够共享一个指向数据源的引用，或者是进行一份拷贝。
## 使用decodeStream加载
在读取图片时，尽量不要使用setImageBitmap、setImageResource、BitmapFactory.decodeResource来加载一张大图，因为这些函数在完成decode后，最终都是通过java层的createBitmap来完成的，需要消耗更多内存。因此，改用先通过BitmapFactory.decodeStream方法，创建出一个bitmap，再将其设为ImageView的source，decodeStream最大的秘密在于其直接调用JNI>>nativeDecodeAsset()来完成decode，无需再使用java层的createBitmap，从而节省了java层的空间。
另外，decodeStream直接拿图片来读取字节码，不会根据机器的各种分辨率来自动适应，因此在使用了decodeStream之后，需要在hdpi和mdpi，ldpi中配置相应的图片资源，否则在不同分辨率机器上都是同样大小（像素点数量），显示出来的大小就不对了。
## 根据占位图对图片进行压缩
对于图片加载库来说，有些图片是从本地加载，有些是从服务器加载，同时很多图片没有对应的View大小进行匹配，很可能传入很大的图片，如果图片加载库直接加载，那么一张超大的图片就会到OOM。
为了避免直接加载图片，就需要对图片进行压缩，这时就需要确定压缩后图片目标size。图片目标size一般有几种做法传入，一种是直接传入目标size，直接传入目标size需要在开发时就指定或者获取图片size，对于调用者来说非常不实用。一种是传入图片所在的View，进而获取View的size，而View在初始化时获取的size都是(0，0)。还有一种方案，在进行图片加载时传入默认的占位图片，将占位图的图片size作为默认的目标size，这样就能避免因为一些原因而传入过大图片而导致内存溢出。
